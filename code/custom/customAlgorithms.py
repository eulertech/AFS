import copy, random

from deap import tools

def varOrExclusive(population, lambda_, cxpb, mutpb):
    """Same as varOr, but disallow offspring which are exactly
        matching some individual already in the population.
    """
    # TODO Make more efficient by sampling without replacement

    assert (cxpb + mutpb) <= 1.0, (
        "The sum of the crossover and mutation probabilities must be smaller "
        "or equal to 1.0.")
    unique_set = set()

    offspring = []
    for _ in xrange(100*lambda_):

        op_choice = random.random()
        if op_choice < cxpb:            # Apply crossover

            ind1, ind2 = map(copy.deepcopy, random.sample(population, 2))
            ind1, ind2 = ind1.mate(ind2) #creating two individuals, but discarding one

            del ind1.fitness.values
            ind1_str = str(ind1)
            if ind1_str not in unique_set:
                offspring.append(ind1)
                unique_set.add(ind1_str)
        elif op_choice < cxpb + mutpb:  # Apply mutation
            ind = copy.deepcopy(random.choice(population))
            ind, = ind.mutate()

            del ind.fitness.values
            ind_str = str(ind)
            if ind_str not in unique_set:
                offspring.append(ind)
                unique_set.add(ind_str)
        else:                           # Apply reproduction
            ind = random.choice(population)
            ind_str = str(ind)
            if ind_str not in unique_set:
                offspring.append(ind)
                unique_set.add(ind_str)
        if len(offspring) >= lambda_:
            break
    # Need to cast the offspring as the class of the population
    return type(population)(offspring)


def eaMuPlusLambdaExclusive(population, mu, lambda_, cxpb, mutpb, ngen,
                   stats=None, halloffame=None, verbose=__debug__, hof_recalculate_flag=False):
    """This is the :math:`(\mu + \lambda)` evolutionary algorithm (with no duplicate individuals allowed in offspring).
    :param population: A list of individuals.
    :param toolbox: A :class:`~deap.base.Toolbox` that contains the evolution
                    operators.
    :param mu: The number of individuals to select for the next generation.
    :param lambda\_: The number of children to produce at each generation.
    :param cxpb: The probability that an offspring is produced by crossover.
    :param mutpb: The probability that an offspring is produced by mutation.
    :param ngen: The number of generation.
    :param stats: A :class:`~deap.tools.Statistics` object that is updated
                  inplace, optional.
    :param halloffame: A :class:`~deap.tools.HallOfFame` object that will
                       contain the best individuals, optional.
    :param verbose: Whether or not to log the statistics.
    :returns: The final population
    :returns: A class:`~deap.tools.Logbook` with the statistics of the
              evolution.
    The algorithm takes in a population and evolves it in place using the
    :func:`varOrExclusive` function. It returns the optimized population and a
    :class:`~deap.tools.Logbook` with the statistics of the evolution. The
    logbook will contain the generation number, the number of evalutions for
    each generation and the statistics if a :class:`~deap.tools.Statistics` is
    given as argument. The *cxpb* and *mutpb* arguments are passed to the
    :func:`varOrExclusive` function. The pseudocode goes as follows ::
        evaluate(population)
        for g in range(ngen):
            offspring = varOrExclusive(population, toolbox, lambda_, cxpb, mutpb)
            evaluate(offspring)
            population = select(population + offspring, mu)
    First, the individuals having an invalid fitness are evaluated. Second,
    the evolutionary loop begins by producing *lambda_* offspring from the
    population, the offspring are generated by the :func:`varOrExclusive` function. The
    offspring are then evaluated and the next generation population is
    selected from both the offspring **and** the population. Finally, when
    *ngen* generations are done, the algorithm returns a tuple with the final
    population and a :class:`~deap.tools.Logbook` of the evolution.
    This function expects :meth:`toolbox.mate`, :meth:`toolbox.mutate`,
    :meth:`toolbox.select` and :meth:`toolbox.evaluate` aliases to be
    registered in the toolbox. This algorithm uses the :func:`varOrExclusive`
    variation.
    """
    logbook = tools.Logbook()
    logbook.header = ['gen', 'nevals'] + (stats.fields if stats else [])

    # Evaluate fitness for every feature
    n_evals = population.evaluate()

    if halloffame is not None:
        halloffame.update(population)

    record = stats.compile(population) if stats is not None else {}
    logbook.record(gen=0, nevals=n_evals, **record)
    if verbose:
        print logbook.stream

    # Begin the generational process
    for gen in range(1, ngen + 1):

        # Vary the population
        offspring = varOrExclusive(population, lambda_, cxpb, mutpb)

        # re-do scoring for hall of fame individuals
        if (hof_recalculate_flag):
            Population = type(population)
            hof_pop = copy.deepcopy( Population(halloffame) )
            offspring_plus_hof = offspring+hof_pop
            n_evals = offspring_plus_hof.evaluate()
            halloffame.update(offspring_plus_hof)
        else:
            n_evals = offspring.evaluate()
            # Update the hall of fame with the generated individuals
            halloffame.update(offspring)

        # Select the next generation population
        population[:] = (population.union(offspring)).select(mu)

        # Update the statistics with the new population
        record = stats.compile(population) if stats is not None else {}
        logbook.record(gen=gen, nevals=n_evals, **record)
        if verbose:
            print logbook.stream

    return population, logbook